diff --git a/src/interpreter/cling/CMakeLists.txt b/src/interpreter/cling/CMakeLists.txt
index 57b4984edd..b0081c5aee 100644
--- a/src/interpreter/cling/CMakeLists.txt
+++ b/src/interpreter/cling/CMakeLists.txt
@@ -184,8 +184,13 @@ else() # Building as part of LLVM
     include(${LLVMCONFIG_FILE})
   endif()
   if (NOT CLANG_INCLUDE_DIRS)
-    set (CLANG_INCLUDE_DIRS "${CMAKE_SOURCE_DIR}/tools/clang/include"
-      "${CMAKE_BINARY_DIR}/tools/clang/include")
+    set (CLANG_INCLUDE_DIRS "${LLVM_MAIN_SRC_DIR}/tools/clang/include")
+    if (NOT EXISTS ${CLANG_INCLUDE_DIRS})
+      # Otherwise assume the monorepo layout.
+      set (CLANG_INCLUDE_DIRS ${LLVM_MAIN_SRC_DIR}/../clang/include )
+    endif()
+    set (CLANG_INCLUDE_DIRS "${CLANG_INCLUDE_DIRS}"
+      "${LLVM_BINARY_DIR}/tools/clang/include")
   endif()
 endif()
 
diff --git a/src/interpreter/cling/include/cling/Interpreter/DynamicLookupRuntimeUniverse.h b/src/interpreter/cling/include/cling/Interpreter/DynamicLookupRuntimeUniverse.h
index 3550275754..8942810f20 100644
--- a/src/interpreter/cling/include/cling/Interpreter/DynamicLookupRuntimeUniverse.h
+++ b/src/interpreter/cling/include/cling/Interpreter/DynamicLookupRuntimeUniverse.h
@@ -55,7 +55,7 @@ namespace runtime {
         // Check whether the expected return type and the actual return type are
         // compatible with Sema::CheckAssingmentConstraints or
         // ASTContext::typesAreCompatible.
-        return result.simplisticCastAs<T>();
+        return result.castAs<T>();
       return T();
     }
 
diff --git a/src/interpreter/cling/include/cling/Interpreter/Value.h b/src/interpreter/cling/include/cling/Interpreter/Value.h
index 829b89ddf3..65375856f9 100644
--- a/src/interpreter/cling/include/cling/Interpreter/Value.h
+++ b/src/interpreter/cling/include/cling/Interpreter/Value.h
@@ -12,9 +12,7 @@
 
 #include "cling/Interpreter/Visibility.h"
 
-#include <stddef.h>
-#include <stdint.h>
-#include <type_traits>
+#include <cstdint> // for uintptr_t
 
 namespace llvm {
   class raw_ostream;
@@ -23,9 +21,66 @@ namespace llvm {
 namespace clang {
   class ASTContext;
   class QualType;
-  class RecordDecl;
 }
 
+// FIXME: Merge with clang::BuiltinType::getName
+#define CLING_VALUE_BUILTIN_TYPES                                      \
+  /*  X(void, Void) */                                                 \
+  X(bool, Bool)                                                        \
+  X(char, Char_S)                                                      \
+  /*X(char, Char_U)*/                                                  \
+  X(signed char, SChar)                                                \
+  X(short, Short)                                                      \
+  X(int, Int)                                                          \
+  X(long, Long)                                                        \
+  X(long long, LongLong)                                               \
+  /*X(__int128, Int128)*/                                              \
+  X(unsigned char, UChar)                                              \
+  X(unsigned short, UShort)                                            \
+  X(unsigned int, UInt)                                                \
+  X(unsigned long, ULong)                                              \
+  X(unsigned long long, ULongLong)                                     \
+  /*X(unsigned __int128, UInt128)*/                                    \
+  /*X(half, Half)*/                                                    \
+  /*X(__bf16, BFloat16)*/                                              \
+  X(float, Float)                                                      \
+  X(double, Double)                                                    \
+  X(long double, LongDouble)                                           \
+  /*X(short _Accum, ShortAccum)                                        \
+    X(_Accum, Accum)                                                   \
+    X(long _Accum, LongAccum)                                          \
+    X(unsigned short _Accum, UShortAccum)                              \
+    X(unsigned _Accum, UAccum)                                         \
+    X(unsigned long _Accum, ULongAccum)                                \
+    X(short _Fract, ShortFract)                                        \
+    X(_Fract, Fract)                                                   \
+    X(long _Fract, LongFract)                                          \
+    X(unsigned short _Fract, UShortFract)                              \
+    X(unsigned _Fract, UFract)                                         \
+    X(unsigned long _Fract, ULongFract)                                \
+    X(_Sat short _Accum, SatShortAccum)                                \
+    X(_Sat _Accum, SatAccum)                                           \
+    X(_Sat long _Accum, SatLongAccum)                                  \
+    X(_Sat unsigned short _Accum, SatUShortAccum)                      \
+    X(_Sat unsigned _Accum, SatUAccum)                                 \
+    X(_Sat unsigned long _Accum, SatULongAccum)                        \
+    X(_Sat short _Fract, SatShortFract)                                \
+    X(_Sat _Fract, SatFract)                                           \
+    X(_Sat long _Fract, SatLongFract)                                  \
+    X(_Sat unsigned short _Fract, SatUShortFract)                      \
+    X(_Sat unsigned _Fract, SatUFract)                                 \
+    X(_Sat unsigned long _Fract, SatULongFract)                        \
+    X(_Float16, Float16)                                               \
+    X(__float128, Float128)                                            \
+    X(__ibm128, Ibm128)*/                                              \
+  X(wchar_t, WChar_S)                                                  \
+  /*X(wchar_t, WChar_U)*/                                              \
+  /*X(char8_t, Char8)*/                                                \
+  X(char16_t, Char16)                                                  \
+  X(char32_t, Char32)                                                  \
+  /*X(std::nullptr_t, NullPtr) same as kPtrOrObjTy*/
+
+
 namespace cling {
   class Interpreter;
 
@@ -40,78 +95,42 @@ namespace cling {
   /// and parameters for function calls.
   ///
   class CLING_LIB_EXPORT Value {
-  protected:
+  public:
     ///\brief Multi-purpose storage.
     ///
     union Storage {
-      long long m_LL;
-      unsigned long long m_ULL;
+#define X(type, name) type m_##name;
+      CLING_VALUE_BUILTIN_TYPES
+#undef X
       void* m_Ptr; /// Can point to allocation, see needsManagedAllocation().
-      float m_Float;
-      double m_Double;
-      long double m_LongDouble;
     };
 
+    enum TypeKind : short {
+      kInvalid = 0,
+#define X(type, name) \
+      k##name,
+      CLING_VALUE_BUILTIN_TYPES
+#undef X
+      kVoid,
+      kPtrOrObjTy
+    };
+
+  protected:
     /// \brief The actual value.
     Storage m_Storage;
 
-    enum EStorageType {
-      kSignedIntegerOrEnumerationType,
-      kUnsignedIntegerOrEnumerationType,
-      kDoubleType,
-      kFloatType,
-      kLongDoubleType,
-      kPointerType,
-      kManagedAllocation,
-      kUnsupportedType
-    };
+    /// \brief If the \c Value class needs to alloc and dealloc memory.
+    bool m_NeedsManagedAlloc = false;
 
-    /// \brief Which part in m_Storage is active.
-    EStorageType m_StorageType;
+    TypeKind m_TypeKind = Value::kInvalid;
 
     /// \brief The value's type, stored as opaque void* to reduce
     /// dependencies.
-    void* m_Type;
+    void* m_Type = nullptr;
 
     ///\brief Interpreter that produced the value.
     ///
-    Interpreter* m_Interpreter;
-
-    /// \brief Retrieve the underlying, canonical, desugared, unqualified type.
-    EStorageType getStorageType() const { return m_StorageType; }
-
-    /// \brief Determine the underlying, canonical, desugared, unqualified type:
-    /// the element of Storage to be used.
-    static EStorageType determineStorageType(clang::QualType QT);
-
-    /// \brief Determine the underlying, canonical, desugared, unqualified type:
-    /// the element of Storage to be used.
-    static constexpr EStorageType determineStorageTypeT(...) {
-      return kManagedAllocation;
-    }
-
-    template <class T, class = typename std::enable_if<std::is_integral<T>::value>::type>
-    static constexpr EStorageType determineStorageTypeT(T*) {
-      return std::is_signed<T>::value
-        ? kSignedIntegerOrEnumerationType
-        : kUnsignedIntegerOrEnumerationType;
-    }
-    static constexpr EStorageType determineStorageTypeT(double*) {
-      return kDoubleType;
-    }
-    static constexpr EStorageType determineStorageTypeT(float*) {
-      return kFloatType;
-    }
-    static constexpr EStorageType determineStorageTypeT(long double*) {
-      return kDoubleType;
-    }
-    template <class T>
-    static constexpr EStorageType determineStorageTypeT(T**) {
-      return kPointerType;
-    }
-    static constexpr EStorageType determineStorageTypeT(void*) {
-      return kUnsupportedType;
-    }
+    Interpreter* m_Interpreter = nullptr;
 
     /// \brief Allocate storage as needed by the type.
     void ManagedAllocate();
@@ -120,65 +139,67 @@ namespace cling {
     ///   dependencies.
     void AssertOnUnsupportedTypeCast() const;
 
-    size_t GetNumberOfElements() const;
+    bool isPointerOrObjectType() const { return m_TypeKind == kPtrOrObjTy; }
+    bool isBuiltinType() const {
+      return m_TypeKind != kInvalid && !isPointerOrObjectType();
+    };
 
-    // Allow simplisticCastAs to be partially specialized.
+    // Allow castAs to be partially specialized.
     template<typename T>
     struct CastFwd {
       static T cast(const Value& V) {
-        EStorageType storageType = V.getStorageType();
-        switch (storageType) {
-        case kSignedIntegerOrEnumerationType:
-          return (T) V.getAs<long long>();
-        case kUnsignedIntegerOrEnumerationType:
-          return (T) V.getAs<unsigned long long>();
-        case kDoubleType:
-          return (T) V.getAs<double>();
-        case kFloatType:
-          return (T) V.getAs<float>();
-        case kLongDoubleType:
-          return (T) V.getAs<long double>();
-        case kPointerType:
-        case kManagedAllocation:
+        if (V.isPointerOrObjectType())
           return (T) (uintptr_t) V.getAs<void*>();
-        case kUnsupportedType:
-          V.AssertOnUnsupportedTypeCast();
+        if (V.isInvalid() || V.isVoid()) {
+#ifndef NDEBUG // Removing this might break inlining
+           V.AssertOnUnsupportedTypeCast();
+#endif // NDEBUG
+           return T();
         }
-        return T();
+        return V.getAs<T>();
       }
     };
-
     template<typename T>
     struct CastFwd<T*> {
       static T* cast(const Value& V) {
-        EStorageType storageType = V.getStorageType();
-        if (storageType == kPointerType
-            || storageType == kManagedAllocation)
+        if (V.isPointerOrObjectType())
           return (T*) (uintptr_t) V.getAs<void*>();
+#ifndef NDEBUG // Removing this might break inlining
         V.AssertOnUnsupportedTypeCast();
-        return 0;
+#endif // NDEBUG
+        return nullptr;
       }
     };
 
-    Value(void* QualTypeAsOpaquePtr, Interpreter& Interp, EStorageType stType):
-      m_StorageType(stType),
-      m_Type(QualTypeAsOpaquePtr),
-      m_Interpreter(&Interp) {
+    /// \brief Get to the value with type checking casting the underlying
+    /// stored value to T.
+    template <typename T> T getAs() const {
+      switch (m_TypeKind) {
+      default:
+#ifndef NDEBUG
+        AssertOnUnsupportedTypeCast();
+#endif // NDEBUG
+        return T();
+#define X(type, name)                                           \
+        case Value::k##name: return (T) m_Storage.m_##name;
+        CLING_VALUE_BUILTIN_TYPES
+#undef X
+      }
     }
 
+    void AssertTypeMismatch(const char* Type) const;
   public:
-    /// \brief Default constructor, creates a value that IsInvalid().
-    Value():
-      m_StorageType(kUnsupportedType), m_Type(nullptr),
-      m_Interpreter(nullptr) {}
+    Value() = default;
     /// \brief Copy a value.
     Value(const Value& other);
     /// \brief Move a value.
     Value(Value&& other):
-      m_Storage(other.m_Storage), m_StorageType(other.m_StorageType),
+      m_Storage(other.m_Storage), m_NeedsManagedAlloc(other.m_NeedsManagedAlloc),
+      m_TypeKind(other.m_TypeKind),
       m_Type(other.m_Type), m_Interpreter(other.m_Interpreter) {
       // Invalidate other so it will not release.
-      other.m_StorageType = kUnsupportedType;
+      other.m_NeedsManagedAlloc = false;
+      other.m_TypeKind = kInvalid;
     }
 
     /// \brief Construct a valid but uninitialized Value. After this call the
@@ -189,16 +210,20 @@ namespace cling {
     /// \brief Destruct the value; calls ManagedFree() if needed.
     ~Value();
 
-    /// \brief Create a valid but ininitialized Value. After this call the
-    ///   value's storage can be accessed; i.e. calls ManagedAllocate() if
-    ///   needed.
+    // Avoid including type_traits.
+    template<typename T>
+    struct dependent_false {
+       static constexpr bool value = false;
+       constexpr operator bool() const noexcept { return value; }
+    };
+    /// \brief Create a valid Value holding a clang::Type deduced from the
+    /// argument. This is useful when we want to create a \c Value with a
+    /// particular value from compiled code.
     template <class T>
-    static Value Create(void* QualTypeAsOpaquePtr, Interpreter& Interp) {
-      EStorageType stType
-        = std::is_reference<T>::value ?
-       determineStorageTypeT((typename std::remove_reference<T>::type**)nullptr)
-        : determineStorageTypeT((T*)nullptr);
-      return Value(QualTypeAsOpaquePtr, Interp, stType);
+    static Value Create(Interpreter& Interp, T val) {
+       static_assert(dependent_false<T>::value,
+                     "Can not instantiate for this type.");
+       return {};
     }
 
     Value& operator =(const Value& other);
@@ -211,57 +236,54 @@ namespace cling {
     /// \brief Whether this type needs managed heap, i.e. the storage provided
     /// by the m_Storage member is insufficient, or a non-trivial destructor
     /// must be called.
-    bool needsManagedAllocation() const {
-      return getStorageType() == kManagedAllocation;
-    }
+    bool needsManagedAllocation() const { return m_NeedsManagedAlloc; }
 
     /// \brief Determine whether the Value has been set.
     //
     /// Determine whether the Value has been set by checking
     /// whether the type is valid.
-    bool isValid() const;
+    bool isValid() const { return m_TypeKind != Value::kInvalid; }
+    bool isInvalid() const { return !isValid(); }
 
     /// \brief Determine whether the Value is set but void.
-    bool isVoid() const;
+    bool isVoid() const { return m_TypeKind == Value::kVoid; }
 
     /// \brief Determine whether the Value is set and not void.
     //
     /// Determine whether the Value is set and not void.
-    /// Only in this case can getAs() or simplisticCastAs() be called.
+    /// Only in this case can we can get the represented value.
     bool hasValue() const { return isValid() && !isVoid(); }
 
-    /// \brief Get a reference to the value without type checking.
-    /// T *must* correspond to type. Else use simplisticCastAs()!
-    template <typename T>
-    T& getAs() { return getAs((T*)0); }
-
-    /// \brief Get the value without type checking.
-    /// T *must* correspond to type. Else use simplisticCastAs()!
-    template <typename T>
-    T getAs() const { return const_cast<Value*>(this)->getAs<T>(); }
-
-    template <typename T>
-    T*& getAs(T**) { return (T*&)getAs((void**)0); }
-    void*& getAs(void**) { return m_Storage.m_Ptr; }
-    double& getAs(double*) { return m_Storage.m_Double; }
-    long double& getAs(long double*) { return m_Storage.m_LongDouble; }
-    float& getAs(float*) { return m_Storage.m_Float; }
-    long long& getAs(long long*) { return m_Storage.m_LL; }
-    unsigned long long& getAs(unsigned long long*) { return m_Storage.m_ULL; }
-
-    void*& getPtr() { return m_Storage.m_Ptr; }
-    double& getDouble() { return m_Storage.m_Double; }
-    long double& getLongDouble() { return m_Storage.m_LongDouble; }
-    float& getFloat() { return m_Storage.m_Float; }
-    long long& getLL() { return m_Storage.m_LL; }
-    unsigned long long& getULL() { return m_Storage.m_ULL; }
-
+    // FIXME: If the cling::Value is destroyed and it handed out an address that
+    // might be accessing invalid memory.
+    void** getPtrAddress() { return &m_Storage.m_Ptr; }
     void* getPtr() const { return m_Storage.m_Ptr; }
-    double getDouble() const { return m_Storage.m_Double; }
-    long double getLongDouble() const { return m_Storage.m_LongDouble; }
-    float getFloat() const { return m_Storage.m_Float; }
-    long long getLL() const { return m_Storage.m_LL; }
-    unsigned long long getULL() const { return m_Storage.m_ULL; }
+    void setPtr(void* Val) { m_Storage.m_Ptr = Val; }
+
+#ifndef NDEBUG
+#define _STRINGIFY(x) #x
+#define STRINGIFY(x) _STRINGIFY(x)
+    // FIXME: Uncomment and debug the various type mismatches.
+    //#define ASSERT_TYPE_MISMATCH(name) AssertTypeMismatch(STRINGIFY(name))
+    #define ASSERT_TYPE_MISMATCH(name)
+#undef STRINGIFY
+#undef _STRINGIFY
+#else
+    #define ASSERT_TYPE_MISMATCH(name)
+#endif // NDEBUG
+#define X(type, name)                                    \
+    type get##name() const {                             \
+      ASSERT_TYPE_MISMATCH(name);                        \
+      return m_Storage.m_##name;                         \
+    }                                                    \
+    void set##name(type Val) {                           \
+      ASSERT_TYPE_MISMATCH(name);                        \
+      m_Storage.m_##name = Val;                          \
+    }                                                    \
+
+  CLING_VALUE_BUILTIN_TYPES
+
+#undef X
 
     /// \brief Get the value with cast.
     //
@@ -269,7 +291,7 @@ namespace cling {
     /// casting the value of builtins (except void), enums and pointers.
     /// Values referencing an object are treated as pointers to the object.
     template <typename T>
-    T simplisticCastAs() const {
+    T castAs() const {
       return CastFwd<T>::cast(*this);
     }
 
@@ -284,6 +306,20 @@ namespace cling {
     void print(llvm::raw_ostream& Out, bool escape = false) const;
     void dump(bool escape = true) const;
   };
+
+  template <> inline void* Value::getAs() const {
+    if (isPointerOrObjectType())
+      return m_Storage.m_Ptr;
+    return (void*)getAs<uintptr_t>();
+  }
+
+#define X(type, name)                                                   \
+  template <> Value Value::Create(Interpreter& Interp, type val);       \
+
+  CLING_VALUE_BUILTIN_TYPES
+
+#undef X
+
 } // end namespace cling
 
 #endif // CLING_VALUE_H
diff --git a/src/interpreter/cling/include/cling/libc_msvc.modulemap b/src/interpreter/cling/include/cling/libc_msvc.modulemap
index b5636b943e..9424a062c4 100644
--- a/src/interpreter/cling/include/cling/libc_msvc.modulemap
+++ b/src/interpreter/cling/include/cling/libc_msvc.modulemap
@@ -32,6 +32,7 @@ module "libc" [system] [extern_c] [no_undeclared_includes] {
     header "stdio.h"
   }
   module "complex.h" {
+    requires missing
     export *
     header "complex.h"
   }
diff --git a/src/interpreter/cling/include/cling/std_msvc.modulemap b/src/interpreter/cling/include/cling/std_msvc.modulemap
index cef3b5e5b6..2dff2bc04d 100644
--- a/src/interpreter/cling/include/cling/std_msvc.modulemap
+++ b/src/interpreter/cling/include/cling/std_msvc.modulemap
@@ -61,6 +61,12 @@ module "std" [system] {
     export *
     header "chrono"
   }
+  module "__msvc_chrono.hpp" {
+    requires msvc1934
+    export xtimec_h
+    export *
+    header "__msvc_chrono.hpp"
+  }
   module "cinttypes" {
     export *
     header "cinttypes"
@@ -439,14 +445,6 @@ module "std" [system] {
     export *
     header "xlocbuf"
   }
-  module "xlocinfo" {
-    export *
-    header "xlocinfo"
-  }
-  module "xlocinfo.h" {
-    export *
-    header "xlocinfo.h"
-  }
   module "xlocmes" {
     export *
     header "xlocmes"
@@ -484,12 +482,14 @@ module "std" [system] {
     header "xstring"
   }
   module "xthreads.h" {
+    export thread
     export *
-    textual header "xthreads.h"
+    header "xthreads.h"
   }
-  module "xtimec.h" {
+  module "xtimec_h" {
+    export chrono
     export *
-    textual header "xtimec.h"
+    header "xtimec.h"
   }
   module "xtr1common" {
     export *
@@ -515,4 +515,14 @@ module "std" [system] {
     export *
     header "yvals_core.h"
   }
+  module "xnode_handle.h" {
+    requires cplusplus17
+    export *
+    header "xnode_handle.h"
+  }
+  module "__msvc_iter_core.hpp" {
+    requires msvc1934
+    export *
+    header "__msvc_iter_core.hpp"
+  }
 }
diff --git a/src/interpreter/cling/lib/Interpreter/DeclExtractor.cpp b/src/interpreter/cling/lib/Interpreter/DeclExtractor.cpp
index 19b01e9f94..8fbbaa6b05 100644
--- a/src/interpreter/cling/lib/Interpreter/DeclExtractor.cpp
+++ b/src/interpreter/cling/lib/Interpreter/DeclExtractor.cpp
@@ -220,7 +220,7 @@ namespace cling {
       WrapperDC->addDecl(FD);
     }
 
-    return hasNoErrors ? FD : 0;
+    return hasNoErrors ? FD != nullptr : false;
   }
 
   void DeclExtractor::createUniqueName(std::string& out) {
@@ -239,57 +239,59 @@ namespace cling {
 
     std::string FunctionName = "__fd";
     createUniqueName(FunctionName);
-    IdentifierInfo& IIFD = m_Context->Idents.get(FunctionName);
+    clang::DeclarationName DeclName = &m_Context->Idents.get(FunctionName);
     SourceLocation Loc;
-    NamedDecl* ND = m_Sema->ImplicitlyDefineFunction(Loc, IIFD, TUScope);
-    if (FunctionDecl* FD = dyn_cast_or_null<FunctionDecl>(ND)) {
-      Sema::SynthesizedFunctionScope Scope(*m_Sema, FD);
-      FD->setImplicit(false); // Better for debugging
-
-      // Add a return statement if it doesn't exist
-      if (!isa<ReturnStmt>(Stmts.back())) {
-        Sema::ContextRAII pushedDC(*m_Sema, FD);
-        // Generate the return statement:
-        // First a literal 0, then the return taking that literal.
-        // One bit is enough:
-        llvm::APInt ZeroInt(m_Context->getIntWidth(m_Context->IntTy), 0,
-                            /*isSigned=*/true);
-        IntegerLiteral* ZeroLit
-          = IntegerLiteral::Create(*m_Context, ZeroInt, m_Context->IntTy,
-                                   SourceLocation());
-        Stmts.push_back(m_Sema->BuildReturnStmt(ZeroLit->getExprLoc(),
-                                                ZeroLit).get());
-      }
-
-      // Wrap Stmts into a function body.
-      llvm::ArrayRef<Stmt*> StmtsRef(Stmts.data(), Stmts.size());
-      CompoundStmt* CS = CompoundStmt::Create(*m_Context, StmtsRef, Loc, Loc);
-      FD->setBody(CS);
-      Emit(FD);
-
-      // Create the VarDecl with the init
-      std::string VarName = "__vd";
-      createUniqueName(VarName);
-      IdentifierInfo& IIVD = m_Context->Idents.get(VarName);
-      VarDecl* VD = VarDecl::Create(*m_Context, TUDC, Loc, Loc, &IIVD,
-                                    FD->getReturnType(), (TypeSourceInfo*)0,
-                                    SC_None);
-      LookupResult R(*m_Sema, FD->getDeclName(), Loc, Sema::LookupMemberName);
-      R.addDecl(FD);
-      CXXScopeSpec CSS;
-      Expr* UnresolvedLookup
-        = m_Sema->BuildDeclarationNameExpr(CSS, R, /*ADL*/ false).get();
-      Expr* TheCall = m_Sema->ActOnCallExpr(TUScope, UnresolvedLookup, Loc,
-                                            MultiExprArg(), Loc).get();
-      assert(VD && TheCall && "Missing VD or its init!");
-      VD->setInit(TheCall);
-
-      Emit(VD); // Add it to the transaction for codegenning
-      TUDC->addHiddenDecl(VD);
-      Stmts.clear();
-      return;
+    clang::QualType FnTy =
+        m_Context->getFunctionType(m_Context->IntTy, {},
+                                   clang::FunctionProtoType::ExtProtoInfo());
+    clang::FunctionDecl* FD = clang::FunctionDecl::Create(
+        *m_Context, m_Context->getTranslationUnitDecl(), Loc, Loc, DeclName,
+        FnTy, m_Context->getTrivialTypeSourceInfo(FnTy), clang::SC_None);
+
+    Sema::SynthesizedFunctionScope Scope(*m_Sema, FD);
+    FD->setImplicit(false); // Better for debugging
+
+    // Add a return statement if it doesn't exist
+    if (!isa<ReturnStmt>(Stmts.back())) {
+      Sema::ContextRAII pushedDC(*m_Sema, FD);
+      // Generate the return statement:
+      // First a literal 0, then the return taking that literal.
+      // One bit is enough:
+      llvm::APInt ZeroInt(m_Context->getIntWidth(m_Context->IntTy), 0,
+                          /*isSigned=*/true);
+      IntegerLiteral* ZeroLit
+        = IntegerLiteral::Create(*m_Context, ZeroInt, m_Context->IntTy,
+                                 SourceLocation());
+      Stmts.push_back(
+          m_Sema->BuildReturnStmt(ZeroLit->getExprLoc(), ZeroLit).get());
     }
-    llvm_unreachable("Must be able to enforce init order.");
+
+    // Wrap Stmts into a function body.
+    llvm::ArrayRef<Stmt*> StmtsRef(Stmts.data(), Stmts.size());
+    CompoundStmt* CS = CompoundStmt::Create(*m_Context, StmtsRef, Loc, Loc);
+    FD->setBody(CS);
+    Emit(FD);
+
+    // Create the VarDecl with the init
+    std::string VarName = "__vd";
+    createUniqueName(VarName);
+    IdentifierInfo& IIVD = m_Context->Idents.get(VarName);
+    VarDecl* VD = VarDecl::Create(*m_Context, TUDC, Loc, Loc, &IIVD,
+                                  FD->getReturnType(), (TypeSourceInfo*)0,
+                                  SC_None);
+    LookupResult R(*m_Sema, FD->getDeclName(), Loc, Sema::LookupMemberName);
+    R.addDecl(FD);
+    CXXScopeSpec CSS;
+    Expr* UnresolvedLookup
+      = m_Sema->BuildDeclarationNameExpr(CSS, R, /*ADL*/ false).get();
+    Expr* TheCall = m_Sema->ActOnCallExpr(TUScope, UnresolvedLookup, Loc,
+                                          MultiExprArg(), Loc).get();
+    assert(VD && TheCall && "Missing VD or its init!");
+    VD->setInit(TheCall);
+
+    Emit(VD); // Add it to the transaction for codegenning
+    TUDC->addHiddenDecl(VD);
+    Stmts.clear();
   }
 
   ///\brief Checks for clashing names when trying to extract a declaration.
diff --git a/src/interpreter/cling/lib/Interpreter/DeclUnloader.cpp b/src/interpreter/cling/lib/Interpreter/DeclUnloader.cpp
index 5d13259cd4..e33ed31912 100644
--- a/src/interpreter/cling/lib/Interpreter/DeclUnloader.cpp
+++ b/src/interpreter/cling/lib/Interpreter/DeclUnloader.cpp
@@ -247,10 +247,10 @@ bool DeclUnloader::VisitRedeclarable(clang::Redeclarable<T>* R, DeclContext* DC)
       for (Globals::iterator I = VisitedGlobals.begin(),
              E = VisitedGlobals.end(); I != E; ++I)
         if (GlobalVariable* GVar = dyn_cast<GlobalVariable>(*I)) {
-          GVar->setInitializer(0);
+          GVar->setInitializer(nullptr);
         }
         else if (GlobalAlias* GA = dyn_cast<GlobalAlias>(*I)) {
-          GA->setAliasee(0);
+          GA->setAliasee(nullptr);
         }
         else {
           Function* F = cast<Function>(*I);
@@ -454,7 +454,7 @@ bool DeclUnloader::VisitRedeclarable(clang::Redeclarable<T>* R, DeclContext* DC)
 
   bool DeclUnloader::VisitDeclaratorDecl(DeclaratorDecl* DD) {
     // VisitDeclaratorDecl: ValueDecl
-    auto found = std::find(m_Sema->UnusedFileScopedDecls.begin(/*ExtSource*/0,
+    auto found = std::find(m_Sema->UnusedFileScopedDecls.begin(/*ExtSource*/nullptr,
                                                                /*Local*/true),
                            m_Sema->UnusedFileScopedDecls.end(), DD);
     if (found != m_Sema->UnusedFileScopedDecls.end())
@@ -592,13 +592,13 @@ bool DeclUnloader::VisitRedeclarable(clang::Redeclarable<T>* R, DeclContext* DC)
         This->getCommonPtr()->Specializations.clear();
 
         //Readd the collected specializations.
-        void* InsertPos = 0;
-        FunctionTemplateSpecializationInfo* FTSI = 0;
+        void* InsertPos = nullptr;
+        FunctionTemplateSpecializationInfo* FTSI = nullptr;
         for (size_t i = 0, e = specializations.size(); i < e; ++i) {
           FTSI = specializations[i]->getTemplateSpecializationInfo();
           assert(FTSI && "Must not be null.");
           // Avoid assertion on add.
-          FTSI->SetNextInBucket(0);
+          FTSI->SetNextInBucket(nullptr);
           This->addSpecialization(FTSI, InsertPos);
         }
 #ifndef NDEBUG
@@ -749,7 +749,7 @@ bool DeclUnloader::VisitRedeclarable(clang::Redeclarable<T>* R, DeclContext* DC)
       // Hopefully LSD->isExternCContext() means that it already does exist
       ExternCContextDecl* ECD = m_Sema->Context.getExternCContextDecl();
       StoredDeclsMap* Map = ECD ? ECD->getLookupPtr() : nullptr;
-      
+
       for (Decl* D : LSD->noload_decls()) {
         if (NamedDecl* ND = dyn_cast<NamedDecl>(D)) {
 
@@ -922,7 +922,7 @@ bool DeclUnloader::VisitRedeclarable(clang::Redeclarable<T>* R, DeclContext* DC)
     const MacroInfo* MI = MD->getMacroInfo();
 
     // If the macro is not defined, this is a noop undef, just return.
-    if (MI == 0)
+    if (!MI)
       return false;
 
     // Remove the pair from the macros
diff --git a/src/interpreter/cling/lib/Interpreter/DynamicLookup.cpp b/src/interpreter/cling/lib/Interpreter/DynamicLookup.cpp
index e426a2e272..2d6bcb224c 100644
--- a/src/interpreter/cling/lib/Interpreter/DynamicLookup.cpp
+++ b/src/interpreter/cling/lib/Interpreter/DynamicLookup.cpp
@@ -958,7 +958,7 @@ namespace cling {
       Value res = Interp->Evaluate(ctor.c_str(), DC,
                                    ExprInfo->isValuePrinterRequested()
                                    );
-      m_Memory = (void*)res.getAs<void*>();
+      m_Memory = res.getPtr();
     }
 
     LifetimeHandler::~LifetimeHandler() {
diff --git a/src/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp b/src/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp
index 5342945ed1..04bebf0558 100644
--- a/src/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp
+++ b/src/interpreter/cling/lib/Interpreter/IncrementalJIT.cpp
@@ -18,11 +18,13 @@
 #include <clang/Basic/TargetInfo.h>
 #include <clang/Basic/TargetOptions.h>
 #include <clang/Frontend/CompilerInstance.h>
 
 #include <llvm/ADT/Triple.h>
+#include <llvm/ExecutionEngine/JITLink/EHFrameSupport.h>
 #include <llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h>
+#include <llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h>
 #include <llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h>
 #include <llvm/ExecutionEngine/SectionMemoryManager.h>
 #include <llvm/IR/LLVMContext.h>
 #include <llvm/Support/raw_ostream.h>
 #include <llvm/Support/Host.h>
@@ -34,6 +37,7 @@
 #endif
 
 using namespace llvm;
+using namespace llvm::jitlink;
 using namespace llvm::orc;
 
 namespace {
@@ -190,6 +194,117 @@ namespace {
     bool needsToReserveAllocationSpace() override { return true; }
   };
 
+  /// A JITLinkMemoryManager for Cling that never frees its allocations.
+  class ClingJITLinkMemoryManager : public JITLinkMemoryManager {
+  public:
+    Expected<std::unique_ptr<Allocation>>
+    allocate(const JITLinkDylib* JD,
+             const SegmentsRequestMap& Request) override {
+      // A copy of InProcessMemoryManager::allocate with an empty implementation
+      // of IPMMAlloc::deallocate.
+
+      using AllocationMap = DenseMap<unsigned, sys::MemoryBlock>;
+
+      // Local class for allocation.
+      class IPMMAlloc : public Allocation {
+      public:
+        IPMMAlloc(AllocationMap SegBlocks) : SegBlocks(std::move(SegBlocks)) {}
+        MutableArrayRef<char> getWorkingMemory(ProtectionFlags Seg) override {
+          assert(SegBlocks.count(Seg) && "No allocation for segment");
+          return {static_cast<char*>(SegBlocks[Seg].base()),
+                  SegBlocks[Seg].allocatedSize()};
+        }
+        JITTargetAddress getTargetMemory(ProtectionFlags Seg) override {
+          assert(SegBlocks.count(Seg) && "No allocation for segment");
+          return pointerToJITTargetAddress(SegBlocks[Seg].base());
+        }
+        void finalizeAsync(FinalizeContinuation OnFinalize) override {
+          OnFinalize(applyProtections());
+        }
+        Error deallocate() override {
+          // Disabled until CallFunc is informed about unloading, and can
+          // re-generate the wrapper (if the decl is still available). See
+          // https://github.com/root-project/root/issues/10898
+          return Error::success();
+        }
+
+      private:
+        Error applyProtections() {
+          for (auto& KV : SegBlocks) {
+            auto& Prot = KV.first;
+            auto& Block = KV.second;
+            if (auto EC = sys::Memory::protectMappedMemory(Block, Prot))
+              return errorCodeToError(EC);
+            if (Prot & sys::Memory::MF_EXEC)
+              sys::Memory::InvalidateInstructionCache(Block.base(),
+                                                      Block.allocatedSize());
+          }
+          return Error::success();
+        }
+
+        AllocationMap SegBlocks;
+      };
+
+      if (!isPowerOf2_64((uint64_t)sys::Process::getPageSizeEstimate()))
+        return make_error<StringError>("Page size is not a power of 2",
+                                       inconvertibleErrorCode());
+
+      AllocationMap Blocks;
+      const sys::Memory::ProtectionFlags ReadWrite =
+          static_cast<sys::Memory::ProtectionFlags>(sys::Memory::MF_READ |
+                                                    sys::Memory::MF_WRITE);
+
+      // Compute the total number of pages to allocate.
+      size_t TotalSize = 0;
+      for (auto& KV : Request) {
+        const auto& Seg = KV.second;
+
+        if (Seg.getAlignment() > sys::Process::getPageSizeEstimate())
+          return make_error<StringError>("Cannot request higher than page "
+                                         "alignment",
+                                         inconvertibleErrorCode());
+
+        TotalSize = alignTo(TotalSize, sys::Process::getPageSizeEstimate());
+        TotalSize += Seg.getContentSize();
+        TotalSize += Seg.getZeroFillSize();
+      }
+
+      // Allocate one slab to cover all the segments.
+      std::error_code EC;
+      auto SlabRemaining =
+          sys::Memory::allocateMappedMemory(TotalSize, nullptr, ReadWrite, EC);
+
+      if (EC)
+        return errorCodeToError(EC);
+
+      // Allocate segment memory from the slab.
+      for (auto& KV : Request) {
+
+        const auto& Seg = KV.second;
+
+        uint64_t SegmentSize =
+            alignTo(Seg.getContentSize() + Seg.getZeroFillSize(),
+                    sys::Process::getPageSizeEstimate());
+        assert(SlabRemaining.allocatedSize() >= SegmentSize &&
+               "Mapping exceeds allocation");
+
+        sys::MemoryBlock SegMem(SlabRemaining.base(), SegmentSize);
+        SlabRemaining =
+            sys::MemoryBlock((char*)SlabRemaining.base() + SegmentSize,
+                             SlabRemaining.allocatedSize() - SegmentSize);
+
+        // Zero out the zero-fill memory.
+        memset(static_cast<char*>(SegMem.base()) + Seg.getContentSize(), 0,
+               Seg.getZeroFillSize());
+
+        // Record the block for this segment.
+        Blocks[KV.first] = std::move(SegMem);
+      }
+
+      return std::unique_ptr<InProcessMemoryManager::Allocation>(
+          new IPMMAlloc(std::move(Blocks)));
+    }
+  };
 
   /// A DynamicLibrarySearchGenerator that uses ResourceTracker to remember
   /// which symbols were resolved through dlsym during a transaction's reign.
@@ -319,10 +433,26 @@ Error RTDynamicLibrarySearchGenerator::tryToGenerate(
     return JD.define(absoluteSymbols(std::move(Symbols)));
   }
 };
 
+static bool UseJITLink(const Triple& TT) {
+  bool jitLink = false;
+  // Default to JITLink on macOS and RISC-V, as done in (recent) LLVM by
+  // LLJITBuilderState::prepareForConstruction.
+  if (TT.getArch() == Triple::riscv64 ||
+      (TT.isOSBinFormatMachO() &&
+       (TT.getArch() == Triple::aarch64 || TT.getArch() == Triple::x86_64))) {
+    jitLink = true;
+  }
+  // Finally, honor the user's choice by setting an environment variable.
+  if (const char* clingJitLink = std::getenv("CLING_JITLINK")) {
+    jitLink = cling::utils::ConvertEnvValueToBool(clingJitLink);
+  }
+  return jitLink;
+}
+
 static std::unique_ptr<TargetMachine>
-CreateTargetMachine(const clang::CompilerInstance& CI) {
+CreateTargetMachine(const clang::CompilerInstance& CI, bool JITLink) {
   CodeGenOpt::Level OptLevel = CodeGenOpt::Default;
   switch (CI.getCodeGenOpts().OptimizationLevel) {
     case 0: OptLevel = CodeGenOpt::None; break;
     case 1: OptLevel = CodeGenOpt::Less; break;
@@ -330,23 +448,39 @@ Error RTDynamicLibrarySearchGenerator::tryToGenerate(
     case 3: OptLevel = CodeGenOpt::Aggressive; break;
     default: OptLevel = CodeGenOpt::Default;
   }

+
+  const Triple &TT = CI.getTarget().getTriple();
+
   using namespace llvm::orc;
-  auto JTMB = JITTargetMachineBuilder(CI.getTarget().getTriple());
+  auto JTMB = JITTargetMachineBuilder(TT);
   JTMB.addFeatures(CI.getTargetOpts().Features);
+  JTMB.getOptions().MCOptions.ABIName = CI.getTarget().getABI().str();
 
   JTMB.setCodeGenOptLevel(OptLevel);
 #ifdef _WIN32
   JTMB.getOptions().EmulatedTLS = false;
 #endif // _WIN32
 
 #if defined(__powerpc64__) || defined(__PPC64__)
   // We have to use large code model for PowerPC64 because TOC and text sections
   // can be more than 2GB apart.
   JTMB.setCodeModel(CodeModel::Large);
 #endif
 
+  if (JITLink) {
+    // Set up the TargetMachine as otherwise done by
+    // LLJITBuilderState::prepareForConstruction.
+    JTMB.setRelocationModel(Reloc::PIC_);
+    // Set the small code except for macOS on AArch64 - it results in relocation
+    // targets that are out-of-range.
+    // TODO: Investigate / report upstream and re-evaluate after a future LLVM
+    // upgrade.
+    if (!(TT.isOSBinFormatMachO() && TT.getArch() == Triple::aarch64))
+      JTMB.setCodeModel(CodeModel::Small);
+  }
+
   return cantFail(JTMB.createTargetMachine());
 }
 
 #if defined(__linux__) && defined(__GLIBC__)
@@ -386,17 +532,31 @@ IncrementalJIT::IncrementalJIT(
     std::unique_ptr<llvm::orc::ExecutorProcessControl> EPC, Error& Err,
     void *ExtraLibHandle, bool Verbose)
     : SkipHostProcessLookup(false),
-      TM(CreateTargetMachine(CI)),
+      m_JITLink(UseJITLink(CI.getTarget().getTriple())),
+      m_TM(CreateTargetMachine(CI, m_JITLink)),
       SingleThreadedContext(std::make_unique<LLVMContext>()) {
   ErrorAsOutParameter _(&Err);
 
   LLJITBuilder Builder;
-  Builder.setDataLayout(TM->createDataLayout());
+  Builder.setDataLayout(m_TM->createDataLayout());
   Builder.setExecutorProcessControl(std::move(EPC));
 
   // Create ObjectLinkingLayer with our own MemoryManager.
   Builder.setObjectLinkingLayerCreator([&](ExecutionSession& ES,
-                                           const Triple& TT) {
+                                           const Triple& TT)
+                                           -> std::unique_ptr<ObjectLayer> {
+    if (m_JITLink) {
+      // For JITLink, we only need a custom memory manager to avoid freeing the
+      // memory segments; the default InProcessMemoryManager (which is mostly
+      // copied above) already does slab allocation to keep all segments
+      // together which is needed for exception handling support.
+      auto ObjLinkingLayer = std::make_unique<ObjectLinkingLayer>(
+          ES, std::make_unique<ClingJITLinkMemoryManager>());
+      ObjLinkingLayer->addPlugin(std::make_unique<EHFrameRegistrationPlugin>(
+          ES, std::make_unique<InProcessEHFrameRegistrar>()));
+      return ObjLinkingLayer;
+    }
+
     auto GetMemMgr = []() { return std::make_unique<ClingMemoryManager>(); };
     auto Layer =
         std::make_unique<RTDyldObjectLinkingLayer>(ES, std::move(GetMemMgr));
@@ -426,7 +586,7 @@ IncrementalJIT::IncrementalJIT(
 
   Builder.setCompileFunctionCreator([&](llvm::orc::JITTargetMachineBuilder)
   -> llvm::Expected<std::unique_ptr<llvm::orc::IRCompileLayer::IRCompiler>> {
-    return std::make_unique<SimpleCompiler>(*TM);
+    return std::make_unique<SimpleCompiler>(*m_TM);
   });
 
   if (Expected<std::unique_ptr<LLJIT>> JitInstance = Builder.create()) {
@@ -446,7 +606,7 @@ IncrementalJIT::IncrementalJIT(
       m_CompiledModules[Unsafe] = std::move(TSM);
     });
 
-  char LinkerPrefix = this->TM->createDataLayout().getGlobalPrefix();
+  char LinkerPrefix = this->m_TM->createDataLayout().getGlobalPrefix();
 
   // Process symbol resolution
   auto HostProcessLookup
@@ -572,7 +732,7 @@ IncrementalJIT::addOrReplaceDefinition(StringRef Name,
     return KnownAddr;
 
   llvm::SmallString<128> LinkerMangledName;
-  char LinkerPrefix = this->TM->createDataLayout().getGlobalPrefix();
+  char LinkerPrefix = this->m_TM->createDataLayout().getGlobalPrefix();
   bool HasLinkerPrefix = LinkerPrefix != '\0';
   if (HasLinkerPrefix && Name.front() == LinkerPrefix) {
     LinkerMangledName.assign(1, LinkerPrefix);
diff --git a/src/interpreter/cling/lib/Interpreter/IncrementalJIT.h b/src/interpreter/cling/lib/Interpreter/IncrementalJIT.h
index c05458c241..170cc40320 100644
--- a/src/interpreter/cling/lib/Interpreter/IncrementalJIT.h
+++ b/src/interpreter/cling/lib/Interpreter/IncrementalJIT.h
@@ -99,7 +99,7 @@ public:
 
   /// @brief Get the TargetMachine used by the JIT.
   /// Non-const because BackendPasses need to update OptLevel.
-  llvm::TargetMachine &getTargetMachine() { return *TM; }
+  llvm::TargetMachine &getTargetMachine() { return *m_TM; }
 
 private:
   std::unique_ptr<llvm::orc::LLJIT> Jit;
@@ -115,8 +115,9 @@ private:
   std::map<const Transaction*, llvm::orc::ResourceTrackerSP> m_ResourceTrackers;
   std::map<const llvm::Module *, llvm::orc::ThreadSafeModule> m_CompiledModules;
 
+  bool m_JITLink;
   // FIXME: Move TargetMachine ownership to BackendPasses
-  std::unique_ptr<llvm::TargetMachine> TM;
+  std::unique_ptr<llvm::TargetMachine> m_TM;
 
   // TODO: We only need the context for materialization. Instead of defining it
   // here we might want to pass one in on a per-module basis.
diff --git a/src/interpreter/cling/lib/Interpreter/Value.cpp b/src/interpreter/cling/lib/Interpreter/Value.cpp
index 52be4a4437..b7aed930be 100644
--- a/src/interpreter/cling/lib/Interpreter/Value.cpp
+++ b/src/interpreter/cling/lib/Interpreter/Value.cpp
@@ -135,16 +135,53 @@ namespace {
 namespace cling {
 
   Value::Value(const Value& other):
-    m_Storage(other.m_Storage), m_StorageType(other.m_StorageType),
+    m_Storage(other.m_Storage), m_NeedsManagedAlloc(other.m_NeedsManagedAlloc),
+    m_TypeKind(other.m_TypeKind),
     m_Type(other.m_Type), m_Interpreter(other.m_Interpreter) {
     if (other.needsManagedAllocation())
       AllocatedValue::getFromPayload(m_Storage.m_Ptr)->Retain();
   }
 
+  static Value::TypeKind getCorrespondingTypeKind(clang::QualType QT,
+                                                  const clang::ASTContext &C) {
+    using namespace clang;
+
+    if (C.hasSameType(QT, C.VoidTy))
+      return Value::kVoid;
+
+    if (const auto *ET = dyn_cast<EnumType>(QT.getTypePtr()))
+      QT = ET->getDecl()->getIntegerType();
+
+    if (!QT->isBuiltinType() || QT->castAs<BuiltinType>()->isNullPtrType())
+      return Value::kPtrOrObjTy;
+
+    switch(QT->getAs<BuiltinType>()->getKind()) {
+    default:
+#ifndef NDEBUG
+      QT->dump();
+#endif // NDEBUG
+      assert(false && "Type not supported");
+      return Value::kInvalid;
+#define X(type, name) \
+      case BuiltinType::name: return Value::k##name;
+      CLING_VALUE_BUILTIN_TYPES
+#undef X
+    }
+  }
+
   Value::Value(clang::QualType clangTy, Interpreter& Interp):
-    m_StorageType(determineStorageType(clangTy)),
-    m_Type(clangTy.getAsOpaquePtr()),
+    m_TypeKind(getCorrespondingTypeKind(clangTy, Interp.getCI()->getASTContext())),
+    m_Type(clangTy.getAsOpaquePtr()), // FIXME: What if clangTy is freed?
     m_Interpreter(&Interp) {
+    if (m_TypeKind == Value::kPtrOrObjTy) {
+      clang::QualType Canon = clangTy.getCanonicalType();
+      if (Canon->isPointerType() || Canon->isObjectType() ||
+          Canon->isReferenceType())
+        if (Canon->isRecordType() || Canon->isConstantArrayType() ||
+            Canon->isMemberPointerType())
+          m_NeedsManagedAlloc = true;
+    }
+
     if (needsManagedAllocation())
       ManagedAllocate();
   }
@@ -157,7 +194,8 @@ namespace cling {
     // Retain new one.
     m_Type = other.m_Type;
     m_Storage = other.m_Storage;
-    m_StorageType = other.m_StorageType;
+    m_NeedsManagedAlloc = other.m_NeedsManagedAlloc;
+    m_TypeKind = other.m_TypeKind;
     m_Interpreter = other.m_Interpreter;
     if (needsManagedAllocation())
       AllocatedValue::getFromPayload(m_Storage.m_Ptr)->Retain();
@@ -172,10 +210,12 @@ namespace cling {
     // Move new one.
     m_Type = other.m_Type;
     m_Storage = other.m_Storage;
-    m_StorageType = other.m_StorageType;
+    m_NeedsManagedAlloc = other.m_NeedsManagedAlloc;
+    m_TypeKind = other.m_TypeKind;
     m_Interpreter = other.m_Interpreter;
     // Invalidate other so it will not release.
-    other.m_StorageType = kUnsupportedType;
+    other.m_NeedsManagedAlloc = false;
+    other.m_TypeKind = kInvalid;
 
     return *this;
   }
@@ -193,16 +233,9 @@ namespace cling {
     return m_Interpreter->getCI()->getASTContext();
   }
 
-  bool Value::isValid() const { return !getType().isNull(); }
-
-  bool Value::isVoid() const {
-    const clang::ASTContext& Ctx = getASTContext();
-    return isValid() && Ctx.hasSameType(getType(), Ctx.VoidTy);
-  }
-
-  size_t Value::GetNumberOfElements() const {
+  static size_t GetNumberOfElements(clang::QualType QT) {
     if (const clang::ConstantArrayType* ArrTy
-        = llvm::dyn_cast<clang::ConstantArrayType>(getType())) {
+        = llvm::dyn_cast<clang::ConstantArrayType>(QT.getTypePtr())) {
       llvm::APInt arrSize(sizeof(size_t)*8, 1);
       do {
         arrSize *= ArrTy->getSize();
@@ -214,30 +247,6 @@ namespace cling {
     return 1;
   }
 
-  Value::EStorageType Value::determineStorageType(clang::QualType QT) {
-    const clang::Type* desugCanon = QT.getCanonicalType().getTypePtr();
-    if (desugCanon->isSignedIntegerOrEnumerationType())
-      return kSignedIntegerOrEnumerationType;
-    else if (desugCanon->isUnsignedIntegerOrEnumerationType())
-      return kUnsignedIntegerOrEnumerationType;
-    else if (desugCanon->isRealFloatingType()) {
-      const clang::BuiltinType* BT = desugCanon->getAs<clang::BuiltinType>();
-      if (BT->getKind() == clang::BuiltinType::Double)
-        return kDoubleType;
-      else if (BT->getKind() == clang::BuiltinType::Float)
-        return kFloatType;
-      else if (BT->getKind() == clang::BuiltinType::LongDouble)
-        return kLongDoubleType;
-    } else if (desugCanon->isPointerType() || desugCanon->isObjectType()
-               || desugCanon->isReferenceType()) {
-      if (desugCanon->isRecordType() || desugCanon->isConstantArrayType()
-          || desugCanon->isMemberPointerType())
-        return kManagedAllocation;
-      return kPointerType;
-    }
-    return kUnsupportedType;
-  }
-
   void Value::ManagedAllocate() {
     assert(needsManagedAllocation() && "Does not need managed allocation");
     void* dtorFunc = 0;
@@ -255,11 +264,46 @@ namespace cling {
     const clang::ASTContext& ctx = getASTContext();
     unsigned payloadSize = ctx.getTypeSizeInChars(getType()).getQuantity();
     m_Storage.m_Ptr = AllocatedValue::CreatePayload(payloadSize, dtorFunc,
-                                                    GetNumberOfElements());
+                                                GetNumberOfElements(getType()));
+  }
+
+  void Value::AssertTypeMismatch(const char* Type) const {
+#ifndef NDEBUG
+    assert(isBuiltinType() && "Must be a builtin!");
+    const clang::BuiltinType *BT = getType()->castAs<clang::BuiltinType>();
+    clang::PrintingPolicy Policy = getASTContext().getPrintingPolicy();
+#endif // NDEBUG
+    assert(BT->getName(Policy).equals(Type));
   }
 
+  static clang::QualType getCorrespondingBuiltin(clang::ASTContext &C,
+                                                 clang::BuiltinType::Kind K) {
+    using namespace clang;
+    switch(K) {
+    default:
+      assert(false && "Type not supported");
+      return {};
+#define BUILTIN_TYPE(Id, SingletonId) \
+      case BuiltinType::Id: return C.SingletonId;
+#include "clang/AST/BuiltinTypes.def"
+    }
+  }
+
+#define X(type, name)                                                   \
+  template <> Value Value::Create(Interpreter& Interp, type val) {      \
+    clang::ASTContext &C = Interp.getCI()->getASTContext();             \
+    clang::BuiltinType::Kind K = clang::BuiltinType::name;              \
+    Value res = Value(getCorrespondingBuiltin(C, K), Interp);           \
+    res.set##name(val);                                                 \
+    return res;                                                         \
+  }                                                                     \
+
+  CLING_VALUE_BUILTIN_TYPES
+
+#undef X
+
   void Value::AssertOnUnsupportedTypeCast() const {
-    assert("unsupported type in Value, cannot cast simplistically!" && 0);
+    assert("unsupported type in Value, cannot cast!" && 0);
   }
 
   namespace valuePrinterInternal {
diff --git a/src/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp b/src/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp
index 5de56b41a9..830d50ace2 100644
--- a/src/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp
+++ b/src/interpreter/cling/lib/Interpreter/ValueExtractionSynthesizer.cpp
@@ -523,44 +523,42 @@ namespace runtime {
     CLING_LIB_EXPORT
     void setValueNoAlloc(void* vpI, void* vpSVR, void* vpQT, char vpOn,
                          float value) {
-      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).getAs<float>() = value;
+      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).setFloat(value);
       dumpIfNoStorage(vpSVR, vpOn);
     }
 
     CLING_LIB_EXPORT
     void setValueNoAlloc(void* vpI, void* vpSVR, void* vpQT, char vpOn,
                          double value) {
-      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).getAs<double>() = value;
+      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).setDouble(value);
       dumpIfNoStorage(vpSVR, vpOn);
     }
 
     CLING_LIB_EXPORT
     void setValueNoAlloc(void* vpI, void* vpSVR, void* vpQT, char vpOn,
                          long double value) {
-      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).getAs<long double>()
-        = value;
+      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).setLongDouble(value);
       dumpIfNoStorage(vpSVR, vpOn);
     }
 
     CLING_LIB_EXPORT
     void setValueNoAlloc(void* vpI, void* vpSVR, void* vpQT, char vpOn,
                          unsigned long long value) {
-      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT)
-        .getAs<unsigned long long>() = value;
+      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).setULongLong(value);
       dumpIfNoStorage(vpSVR, vpOn);
     }
 
     CLING_LIB_EXPORT
     void setValueNoAlloc(void* vpI, void* vpSVR, void* vpQT, char vpOn,
                          const void* value){
-      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).getAs<void*>()
-        = const_cast<void*>(value);
+      allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT)
+        .setPtr(const_cast<void*>(value));
       dumpIfNoStorage(vpSVR, vpOn);
     }
 
     CLING_LIB_EXPORT
     void* setValueWithAlloc(void* vpI, void* vpSVR, void* vpQT, char vpOn) {
-      return allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).getAs<void*>();
+      return allocateStoredRefValueAndGetGV(vpI, vpSVR, vpQT).getPtr();
     }
   } // end namespace internal
 } // end namespace runtime
diff --git a/src/interpreter/cling/lib/Interpreter/ValuePrinter.cpp b/src/interpreter/cling/lib/Interpreter/ValuePrinter.cpp
index 7841226774..f16f9406fc 100644
--- a/src/interpreter/cling/lib/Interpreter/ValuePrinter.cpp
+++ b/src/interpreter/cling/lib/Interpreter/ValuePrinter.cpp
@@ -762,7 +762,7 @@ static std::string printEnumValue(const Value &V) {
   const clang::EnumType *EnumTy = Ty.getNonReferenceType()->getAs<clang::EnumType>();
   assert(EnumTy && "ValuePrinter.cpp: ERROR, printEnumValue invoked for a non enum type.");
   clang::EnumDecl *ED = EnumTy->getDecl();
-  uint64_t value = V.getULL();
+  uint64_t value = V.getULongLong();
   bool IsFirst = true;
   llvm::APSInt ValAsAPSInt = C.MakeIntValue(value, Ty);
   for (clang::EnumDecl::enumerator_iterator I = ED->enumerator_begin(),
@@ -906,33 +906,33 @@ static std::string printUnpackedClingValue(const Value &V) {
       = llvm::dyn_cast<clang::BuiltinType>(Td.getCanonicalType().getTypePtr())) {
     switch (BT->getKind()) {
       case clang::BuiltinType::Bool:
-        return executePrintValue<bool>(V, V.getLL());
+        return executePrintValue<bool>(V, V.castAs<bool>());
 
       case clang::BuiltinType::Char_S:
-        return executePrintValue<signed char>(V, V.getLL());
+        return executePrintValue<signed char>(V, V.castAs<signed char>());
       case clang::BuiltinType::SChar:
-        return executePrintValue<signed char>(V, V.getLL());
+         return executePrintValue<signed char>(V, V.castAs<signed char>());
       case clang::BuiltinType::Short:
-        return executePrintValue<short>(V, V.getLL());
+        return executePrintValue<short>(V, V.castAs<short>());
       case clang::BuiltinType::Int:
-        return executePrintValue<int>(V, V.getLL());
+        return executePrintValue<int>(V, V.castAs<int>());
       case clang::BuiltinType::Long:
-        return executePrintValue<long>(V, V.getLL());
+        return executePrintValue<long>(V, V.castAs<long>());
       case clang::BuiltinType::LongLong:
-        return executePrintValue<long long>(V, V.getLL());
+        return executePrintValue<long long>(V, V.castAs<long long>());
 
       case clang::BuiltinType::Char_U:
-        return executePrintValue<unsigned char>(V, V.getULL());
+        return executePrintValue<unsigned char>(V, V.castAs<unsigned char>());
       case clang::BuiltinType::UChar:
-        return executePrintValue<unsigned char>(V, V.getULL());
+        return executePrintValue<unsigned char>(V, V.castAs<unsigned char>());
       case clang::BuiltinType::UShort:
-        return executePrintValue<unsigned short>(V, V.getULL());
+        return executePrintValue<unsigned short>(V, V.castAs<unsigned short>());
       case clang::BuiltinType::UInt:
-        return executePrintValue<unsigned int>(V, V.getULL());
+        return executePrintValue<unsigned int>(V, V.castAs<unsigned int>());
       case clang::BuiltinType::ULong:
-        return executePrintValue<unsigned long>(V, V.getULL());
+        return executePrintValue<unsigned long>(V, V.castAs<unsigned long>());
       case clang::BuiltinType::ULongLong:
-        return executePrintValue<unsigned long long>(V, V.getULL());
+        return executePrintValue<unsigned long long>(V, V.castAs<unsigned long long>());
 
       case clang::BuiltinType::Float:
         return executePrintValue<float>(V, V.getFloat());
diff --git a/src/interpreter/cling/lib/MetaProcessor/MetaSema.cpp b/src/interpreter/cling/lib/MetaProcessor/MetaSema.cpp
index abad20f990..ace4fb2f9f 100644
--- a/src/interpreter/cling/lib/MetaProcessor/MetaSema.cpp
+++ b/src/interpreter/cling/lib/MetaProcessor/MetaSema.cpp
@@ -141,7 +141,7 @@ namespace cling {
       return (m_Interpreter.echo(OS.str(), ret) == Interpreter::kSuccess)
               ? CR_Success : CR_Failure;
     };
-    
+
     cling::Transaction* T = nullptr;
     if (actOnLCommand(file, &T) != AR_Success || !T)
       return AR_Failure;
@@ -469,7 +469,7 @@ namespace cling {
       clang::ASTContext& Ctx = m_Interpreter.getCI()->getASTContext();
       if (result) {
         *result = Value(Ctx.IntTy, m_Interpreter);
-        result->getAs<long long>() = exitStatus;
+        result->setLongLong(exitStatus); // FIXME: This should assert.
       }
       return (exitStatus == 0) ? AR_Success : AR_Failure;
     }
diff --git a/src/interpreter/cling/lib/UserInterface/UserInterface.cpp b/src/interpreter/cling/lib/UserInterface/UserInterface.cpp
index 77b254731a..6aa015b8f5 100644
--- a/src/interpreter/cling/lib/UserInterface/UserInterface.cpp
+++ b/src/interpreter/cling/lib/UserInterface/UserInterface.cpp
@@ -13,9 +13,10 @@
 #include "cling/MetaProcessor/MetaProcessor.h"
 #include "cling/Utils/Output.h"
 #include "textinput/Callbacks.h"
-#include "textinput/TextInput.h"
+#include "textinput/History.h"
 #include "textinput/StreamReader.h"
 #include "textinput/TerminalDisplay.h"
+#include "textinput/TextInput.h"
 
 #include "llvm/ADT/SmallString.h"
 #include "llvm/Support/ErrorHandling.h"
@@ -66,6 +67,45 @@ namespace {
 
     textinput::TextInput* operator -> () { return &m_Input; }
   };
+
+  llvm::SmallString<512> GetHistoryFilePath() {
+    if (getenv("CLING_NOHISTORY")) {
+      return {};
+    }
+
+    if (const char* HistFileEnvvar = std::getenv("CLING_HISTFILE")) {
+      return llvm::StringRef{HistFileEnvvar};
+    }
+
+    // History file search order according to XDG Base Directory Specification:
+    //
+    // ${XDG_STATE_HOME}/cling/history
+    // ~/.local/state/cling/history
+    // ~/.cling_history
+    const char* StateHome = std::getenv("XDG_STATE_HOME");
+
+    if (!StateHome) {
+      StateHome = "~/.local/state";
+    }
+
+    llvm::SmallString<512> FilePath;
+
+    if (!llvm::sys::fs::real_path(StateHome, FilePath, true)) {
+      // If xdg state home directory exists then create cling subdirectory if
+      // the latter does not exist.
+      if (llvm::sys::fs::is_directory(FilePath) &&
+          !llvm::sys::fs::create_directory(FilePath += "/cling")) {
+        return FilePath += "/history";
+      }
+    }
+
+    if (llvm::sys::path::home_directory(FilePath)) {
+      return FilePath += "/.cling_history";
+    }
+
+    cling::errs() << "Failed to create command history file\n";
+    return {};
+  }
 }
 
 namespace cling {
@@ -82,12 +122,7 @@ namespace cling {
       PrintLogo();
     }
 
-    llvm::SmallString<512> histfilePath;
-    if (!getenv("CLING_NOHISTORY")) {
-      // History file is $HOME/.cling_history
-      if (llvm::sys::path::home_directory(histfilePath))
-        llvm::sys::path::append(histfilePath, ".cling_history");
-    }
+    auto histfilePath{GetHistoryFilePath()};
 
     const auto Completion =
         std::make_unique<UITabCompletion>(m_MetaProcessor->getInterpreter());
@@ -95,6 +130,17 @@ namespace cling {
 
     TI->SetCompletion(Completion.get());
 
+    if (const char* HistSizeEnvvar = std::getenv("CLING_HISTSIZE")) {
+      const size_t HistSize = std::strtoull(HistSizeEnvvar, nullptr, 0);
+
+      // std::strtoull() returns 0 if the parsing fails.
+      // zero HistSize will disable history logging to file.
+      // refer to textinput::History::AppendToFile()
+      TI->SetHistoryMaxDepth(HistSize);
+      TI->SetHistoryPruneLength(
+          static_cast<size_t>(textinput::History::kPruneLengthDefault));
+    }
+
     bool Done = false;
     std::string Line;
     std::string Prompt("[cling]$ ");
diff --git a/src/interpreter/cling/lib/Utils/AST.cpp b/src/interpreter/cling/lib/Utils/AST.cpp
index 1126ac6382..d41e9b3590 100644
--- a/src/interpreter/cling/lib/Utils/AST.cpp
+++ b/src/interpreter/cling/lib/Utils/AST.cpp
@@ -1672,9 +1672,9 @@ namespace utils {
             && !(ns && ns->isAnonymousNamespace())) {
           prefix_qualifiers = QT.getLocalQualifiers();
           prefix = GetFullyQualifiedNameSpecifier(Ctx, prefix);
-          QT = QualType(etype_input->getNamedType().getTypePtr(),0);
+          QT = QualType(etype_input->getNamedType().getTypePtr(), 0);
         } else {
-          prefix = 0;
+          prefix = nullptr;
         }
       }
     } else {
diff --git a/src/interpreter/cling/test/Interfaces/evaluate.C b/src/interpreter/cling/test/Interfaces/evaluate.C
index cbec8ea80b..02b9254033 100644
--- a/src/interpreter/cling/test/Interfaces/evaluate.C
+++ b/src/interpreter/cling/test/Interfaces/evaluate.C
@@ -141,7 +141,7 @@ namespace cling {
   }
 }
 void dumpTracerSVR(cling::Value& svr) {
-  ((Tracer*)svr.getAs<void*>())->dump("dump");
+  ((Tracer*)svr.castAs<void*>())->dump("dump");
 }
 .rawInput 0
 
diff --git a/src/interpreter/cling/tools/demo/cling-demo.cpp b/src/interpreter/cling/tools/demo/cling-demo.cpp
index 4ca2a86560..28764e3e91 100644
--- a/src/interpreter/cling/tools/demo/cling-demo.cpp
+++ b/src/interpreter/cling/tools/demo/cling-demo.cpp
@@ -31,13 +31,13 @@ void useHeader(cling::Interpreter& interp) {
 
   cling::Value res; // Will hold the result of the expression evaluation.
   interp.process("aGlobal;", &res);
-  std::cout << "aGlobal is " << res.getAs<long long>() << '\n';
+  std::cout << "aGlobal is " << res.castAs<long long>() << '\n';
   interp.process("getAnotherGlobal();", &res);
-  std::cout << "getAnotherGlobal() returned " << res.getAs<float>() << '\n';
+  std::cout << "getAnotherGlobal() returned " << res.getFloat() << '\n';
 
   setAnotherGlobal(1.); // We modify the compiled value,
   interp.process("getAnotherGlobal();", &res); // does the interpreter see it?
-  std::cout << "getAnotherGlobal() returned " << res.getAs<float>() << '\n';
+  std::cout << "getAnotherGlobal() returned " << res.getFloat() << '\n';
 
   // We modify using the interpreter, now the binary sees the new value.
   interp.process("setAnotherGlobal(7.777); getAnotherGlobal();");
diff --git a/src/interpreter/cling/tools/plugins/clad/CMakeLists.txt b/src/interpreter/cling/tools/plugins/clad/CMakeLists.txt
index fb4a3ae28f..44443b1873 100644
--- a/src/interpreter/cling/tools/plugins/clad/CMakeLists.txt
+++ b/src/interpreter/cling/tools/plugins/clad/CMakeLists.txt
@@ -66,7 +66,7 @@ list(APPEND _clad_cmake_logging_settings LOG_OUTPUT_ON_FAILURE ON)
 ExternalProject_Add(
   clad
   GIT_REPOSITORY https://github.com/vgvassilev/clad.git
-  GIT_TAG v1.0
+  GIT_TAG v1.1
   UPDATE_COMMAND ""
   CMAKE_ARGS -G ${CMAKE_GENERATOR}
              -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
